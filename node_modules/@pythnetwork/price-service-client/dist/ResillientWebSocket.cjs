/* eslint-disable @typescript-eslint/no-floating-promises */ /* eslint-disable @typescript-eslint/no-misused-promises */ /* eslint-disable @typescript-eslint/no-unsafe-argument */ /* eslint-disable @typescript-eslint/no-non-null-assertion */ /* eslint-disable @typescript-eslint/no-unnecessary-condition */ /* eslint-disable unicorn/prefer-add-event-listener */ /* eslint-disable @typescript-eslint/require-await */ /* eslint-disable @typescript-eslint/restrict-template-expressions */ /* eslint-disable @typescript-eslint/no-empty-function */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "ResilientWebSocket", {
    enumerable: true,
    get: function() {
        return ResilientWebSocket;
    }
});
const _isomorphicws = /*#__PURE__*/ _interop_require_default(require("isomorphic-ws"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const PING_TIMEOUT_DURATION = 30_000 + 3000; // It is 30s on the server and 3s is added for delays
class ResilientWebSocket {
    endpoint;
    wsClient;
    wsUserClosed;
    wsFailedAttempts;
    pingTimeout;
    logger;
    onError;
    onMessage;
    onReconnect;
    constructor(endpoint, logger){
        this.endpoint = endpoint;
        this.logger = logger;
        this.wsFailedAttempts = 0;
        this.onError = (error)=>{
            this.logger?.error(error);
        };
        this.wsUserClosed = true;
        this.onMessage = ()=>{};
        this.onReconnect = ()=>{};
    }
    async send(data) {
        this.logger?.info(`Sending ${data}`);
        await this.waitForMaybeReadyWebSocket();
        if (this.wsClient === undefined) {
            this.logger?.error("Couldn't connect to the websocket server. Error callback is called.");
        } else {
            this.wsClient.send(data);
        }
    }
    async startWebSocket() {
        if (this.wsClient !== undefined) {
            return;
        }
        this.logger?.info(`Creating Web Socket client`);
        this.wsClient = new _isomorphicws.default(this.endpoint);
        this.wsUserClosed = false;
        this.wsClient.addEventListener("open", ()=>{
            this.wsFailedAttempts = 0;
            // Ping handler is undefined in browser side so heartbeat is disabled.
            if (this.wsClient.on !== undefined) {
                this.heartbeat();
            }
        });
        this.wsClient.onerror = (event)=>{
            this.onError(event.error);
        };
        this.wsClient.onmessage = (event)=>{
            this.onMessage(event.data);
        };
        this.wsClient.addEventListener("close", async ()=>{
            if (this.pingTimeout !== undefined) {
                clearInterval(this.pingTimeout);
            }
            if (this.wsUserClosed) {
                this.logger?.info("The connection has been closed successfully.");
            } else {
                this.wsFailedAttempts += 1;
                this.wsClient = undefined;
                const waitTime = expoBackoff(this.wsFailedAttempts);
                this.logger?.error(`Connection closed unexpectedly or because of timeout. Reconnecting after ${waitTime}ms.`);
                await sleep(waitTime);
                this.restartUnexpectedClosedWebsocket();
            }
        });
        if (this.wsClient.on !== undefined) {
            // Ping handler is undefined in browser side
            this.wsClient.on("ping", this.heartbeat.bind(this));
        }
    }
    /**
   * Heartbeat is only enabled in node clients because they support handling
   * ping-pong events.
   *
   * This approach only works when server constantly pings the clients which.
   * Otherwise you might consider sending ping and acting on pong responses
   * yourself.
   */ heartbeat() {
        this.logger?.info("Heartbeat");
        if (this.pingTimeout !== undefined) {
            clearTimeout(this.pingTimeout);
        }
        this.pingTimeout = setTimeout(()=>{
            this.logger?.warn(`Connection timed out. Reconnecting...`);
            this.wsClient?.terminate();
            this.restartUnexpectedClosedWebsocket();
        }, PING_TIMEOUT_DURATION);
    }
    async waitForMaybeReadyWebSocket() {
        let waitedTime = 0;
        while(this.wsClient !== undefined && this.wsClient.readyState !== this.wsClient.OPEN){
            if (waitedTime > 5000) {
                this.wsClient.close();
                return;
            } else {
                waitedTime += 10;
                await sleep(10);
            }
        }
    }
    async restartUnexpectedClosedWebsocket() {
        if (this.wsUserClosed) {
            return;
        }
        await this.startWebSocket();
        await this.waitForMaybeReadyWebSocket();
        if (this.wsClient === undefined) {
            this.logger?.error("Couldn't reconnect to websocket. Error callback is called.");
            return;
        }
        this.onReconnect();
    }
    closeWebSocket() {
        if (this.wsClient !== undefined) {
            const client = this.wsClient;
            this.wsClient = undefined;
            client.close();
        }
        this.wsUserClosed = true;
    }
}
async function sleep(ms) {
    return new Promise((resolve)=>setTimeout(resolve, ms));
}
function expoBackoff(attempts) {
    return 2 ** attempts * 100;
}
